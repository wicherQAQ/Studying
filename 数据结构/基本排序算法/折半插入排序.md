# 折半插入排序
*算法思想：将*比较*和*移动*这两个操作分离出来，就是先利用折半查找插入的位置，然后一次性移动元素，再插入该元素。*

*时间复杂度：*
> 与直接插入排序相比，折半插入排序只是在寻找插入位置时的比较次数减少，每个待插入元素比较的次数大约在log2n(折半查找判定树)，所以n个元素比较操作的时间复杂度为O(nlog2n)

> 但由于在移动关键字的次数方面直接和折半是一样的，所以折半的时间复杂度还是O(n^2)。


*稳定排序*

``
//注意：A[0]位置不存数据。
void insertSort(ElemType A[],int n){
	int i,j;
	//用于折半查找的指针变量
	int low,high,mid;
	//i=2代表从第二个元素开始，第1个元素可以认为是有序的。
	//如果待插入的元素比前一个元素大，则不需要移动位置。
	//注意：待插入元素之前的所有元素都已排好序。
	for(i=2;i<=n;i++){
		//保存待插入的值
		A[0]=A[i];
		//折半的头指针指向有序数组的第一位，尾指针指向当前数据的前一位-即有序数组的最后一位
		low=1;high=i-1;
		//1.先通过折半查找，找到待插入的位置
		while(low<=high){
			mid = (low+high)/2;
			if(A[mid].key>A[0]){
				//说明待插入的值在中间指针的左边
				high=mid-1;
			}else{
				//说明待插入的值在中间指针的右边
				low=mid+1;
			}
		}		
		//2.通过找好的位置high+1，将涉及到的数据进行挪位
		//从i-1号位开始挪，因为i号位是目标元素
		//一直挪到high+1号位
		for(j=i-1;j>=high+1;--j){
				A[j+1]=A[j];
		}
		A[high+1]=A[0];
	}
}
``