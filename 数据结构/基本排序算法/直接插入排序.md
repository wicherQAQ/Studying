# 直接插入排序
>算法思想：
>>首先以**第一个元素为有序序列**，然后将后面的元素依次插入到**有序的序列中的合适位置**，直到所有元素都插入有序序列。

>空间复杂度：
>>在下标为0处存储哨兵，是常数个辅助空间大小，所以空间复杂度是**O(1)**

>时间复杂度：
>>最坏情况：**O(n^2)** 

>>最好条件**O(n)**

>算法的是否稳定：
>>稳定排序


```
//注意：A[0]位置不存数据。
void insertSort(ElemType A[],int n){
	int i,j;
	//i=2代表从第二个元素开始，第1个元素可以认为是有序的。
	for(i=2;i<=n;i++){
		//如果待插入的元素比前一个元素大，则不需要移动位置。
		//注意：待插入元素之前的所有元素都已排好序。
		if(A[i].key<A[i-1].key){
			//将待插入元素先放置到空闲的A[0]位置；方便元素进行挪位。
			A[0]=A[i];
			//遍历排好序的数组，从有序数组自后往前，将大于目标数据的元素往后挪一位
			for(j=i-1;A[0].key<A[j].key;--j){
				A[j+1]=A[j];
			}
			//将待插入的位置赋值为A[0]目标数据
			A[j+1]=A[0];
		}
	}
}
```