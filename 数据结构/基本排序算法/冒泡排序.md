# 冒泡排序
>算法思想：
>>从前往后（或者从后往前）**两两比较相邻元素的值**，若为逆序（即A[i-1]>A[i]），则交换它们，直到序列比较完。我们称其为一趟冒泡，结果将最小（或最大）的元素交换到待排序的第一个位置，下一趟冒泡，前一趟的最小或最大元素将不参与比较，以此类推，知道所有元素都有序。这样最多做n-1趟冒泡就能完成排序。

>空间复杂度：
>>交换时开辟了存储空间temp来存储中间变量，所以空间复杂度为**O(1)**

>时间复杂度：
>>最坏情况：**O(n^2)** 
>>该算法基本操作就是在于交换两个数据。
>>最坏情况下，初试序列就是逆序，每一次外层循环，内层循环始终成立

>>最好条件：**O(n)**
>>初始序列就是有序的，内层条件始终不成立，内层执行n-1次后结束

>算法的是否稳定：
>>稳定排序
>>只有满足大于或小于才会发生交换


```
/**
 * @param A[] 待排序数组
 * @param n 数组元素个数 
 */
void BubbleSort(ElemType A[],int n){
	int i,j;
	for(i=0;i<n-1;i++){
	    //标志位，用来判断是否发生交换
	    //若没有发生交换，则证明序列有序
	    boolean flag = false;
	    
	    //从后往前冒泡，小的数往前挪，最终从小到大排序
	    for(j=n-1;j>i;j--){ //一趟冒泡过程
	        if(A[j-1].key>A[j].key){ //若前面的元素大于后面的元素，则两两交换
	            ElemType temp = A[j-1].key;
	            A[j-1].key = A[j].key;
	            A[j].key = temp;
	            flag = ture; //若发生数据交换，则令flag标志位为true，代表本趟冒泡有数据交换。
	        }
	    }
	    //若标志位flag为ture，则说明序列已经排好序了。
	    if(!flag){
	        return;
	    }
	}
}
```